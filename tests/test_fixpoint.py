import pytest
import binascii
from miasmX.arch.ia32_arch import x86mnemo

tests = [
    "cmp eax, -1",
    "cmp eax, 255",
    "cmp al, -66",
    "cmp al, 190",
    "cmp al, 166",
    "mov BYTE PTR [ebp], -2",
    "lea edx, [eax+132]",
    "mov eax, DWORD PTR eax",
    "mov eax, DWORD PTR [eax]",
    "mov       eax, dword ptr gs:[0x00000014]" ,
    "mov       dword ptr [esp+0x0000001C], 0x00000000",
    "movsx     eax, al",
    "shr       edx, 0x0000001F",
    "mov  DWORD PTR [esp+20], OFFSET FLAT:toto",
    "jne       0x0000001F",
    "mov  eax, OFFSET FLAT:.LC0",
    "jz           .LC0",
    "fucomip      st1",
    "fucomip      st, st(1)",
    "fucomi       st1",
    "fcomi        st1",
    "fdivp        st1",
    "push es",
    "in al, dx",
    "movsb     byte ptr es:[edi], byte ptr ds:[esi]",
    "cmpsb",
    "cmpsb     byte ptr es:[edi], byte ptr ds:[esi]",
    "fadd st0, st1",
    "mov  BYTE PTR [ebp], 2",
    "imul      eax, eax, 0x000000C8",
    "fld  QWORD PTR [esp+8]",
    "faddp st(1), st",
    "fsubp st(1), st",
    "fdivp        st(1), st",
    "lea       ecx, dword ptr [edx+eax]",
    "mov     eax, DWORD PTR [ebp+12]",
    "mov     eax, DWORD PTR polys[0+eax*8]",
    "movzx     eax, word ptr [2*eax+0x00000000]",
    "lea ecx, [edx+eax]",
    "lea ecx, [edx+eax+0x00000000C]",
    "lea ecx, [eax+eax]",
    "mov eax, DWORD PTR A[0+eax*4]",
    "mov dword ptr [esp+8], eax",
    "aaa",
    "rep movsd",
    "movsd",
    "movsb",
    "stosb",
    "sete    BYTE PTR [esp+31]",
    "cwde",
    "fadd st, st(0)",
    "fadd QWORD PTR [esp+56]",
    "sar eax",
    "sal eax, cl",
    "sal eax, 1",
    "sar eax, cl",
    "sar eax, 1",
    "shr eax, cl",
    "shr eax, 1",
    "aad 10",
    "aam 10",
    "aad",
    "stc",
    "aas",
    "mov eax, DWORD PTR ac",
    "add  DWORD PTR [ebp-4], 66",
    "lea ecx, [eax+132]",
    "aam",
    "push           dword ptr 20" ,
    "push           dword ptr gs:20" ,
    "xchg edx, eax" ,
    "xchg eax, edx" ,
    "scasb" ,
    "pop DWORD PTR [edi+eax+303459835]" ,
    "mov  eax, OFFSET FLAT:.LC0-.LC1",
    "mov  eax, .LC0-.LC1",
    "mov  eax, .LVARTMP91-.L90",
    "mov  eax, (Lvartmp91)-Lvartmp90",
    "mov     BYTE PTR [ebp-9], -2",
    "xor     BYTE PTR AZCAER_+41359, -128",
    "mov  BYTE PTR [ebp], -2",
    "lea     edi, toto[eax+1512]",
    "fdivrp  st(1), st",
    "fsubrp  st(1), st",
    "lea ecx, [eax+edx]",
    "fadd DWORD PTR [esp+56]",
    "fsub DWORD PTR [esp+56]",
    "fld  QWORD PTR [8*%eax+%ebp-216]",
    "fld  QWORD PTR [8*eax+ebp-216]",
    "lea %ecx, [%eax+%edx]",
    "fmulp     %st(1), %st",
    "fadd     st, st(0)",
    "fsub     st, st(0)",
    "fmul     st, st(1)",
    "mov eax, DWORD PTR [eax+esp]",
    "fldenv DWORD PTR [eax]",
    "fldenv DWORD PTR [%eax]",
    "fchs",
    "mov si, 32",
    "mov si, WORD PTR[ebp-3]",
    "mov WORD PTR 0, ax",
    "test al, 120",
    "test al, -120",
    "fcmovu st, st(1)",
    "fcmovb st, st(1)",
    "fcmove st, st(1)",
    "fcmovbe st, st(1)",
    "fxam",
    "fstp DWORD PTR [ebp-92]",
    "fstp TBYTE PTR [ebp-92]",
    "or dl, -42",
    "or ah, 128",
    "xor edx, 128",
    "and DWORD PTR [eax], 0x10",
    "and BYTE PTR [eax], 0x10",
    "mov eax, DWORD PTR 8[ebp]",
    "mov eax, DWORD PTR -8[ebp]",
    "jmp [DWORD PTR .L40[0+eax*4]]",
    "call [DWORD PTR R]",
    "call [DWORD PTR [esp+16+eax*4]]",
    "lea eax, .LC0@GOTOFF[ebx]",
    "mov BYTE PTR 53[eax], -128",
    "sete al",
    "fnstcw WORD PTR[eax]",
    "fnstsw WORD PTR[eax]",
    "fnstsw ax",
    "fnstsw %ax",
    "fnstsw",
    "fdivr QWORD PTR -112[ebp]",
    "fucom st(0)",
    "fucom",
    "fucomp st(0)",
    "fucomp",
    "fucompp",
    "fild WORD PTR ds:0",
    "fild DWORD PTR ds:0",
    "movsx si, BYTE PTR [edx+1]",
    "shrd DWORD PTR edi, ebp, 1",
    "shrd edi, ebp, 1",
    "shld edi, ebp, 1",
    "frndint",
    "mov edx, DWORD PTR offset@GOTOFF[ebx]",
    "mov DWORD PTR sp@GOTOFF[ebx], eax",
    "sub eax, -145739803",
    "lea eax, -8+a[ebx]",
    "lea ebx, [0+eax*4]",
    "call [DWORD PTR R]",
    "fnop",
    "fst st(0)",
    "fstp st(0)",
    "fstp QWORD PTR[esp]",
    "mov       eax, dword ptr gs:20" ,
    "repnz scasb",
    "ffree st(2)",
    "ffreep st(0)",
    "lea esi, [esi]",
    "movsb",
    "movsd",
    "movsw",
    "xadd DWORD PTR [eax+8], edx",
    "lock xadd DWORD PTR [eax+8], edx",
    "movss xmm1, xmm0",
    "xorps xmm0, xmm0",
    "movaps XMMWORD PTR [ebx+148], xmm1",
    "movlps QWORD PTR [eax+20], xmm0",
    "movhps QWORD PTR [eax+20], xmm0",
    "prefetcht0 [ebx+64]",
    "prefetchw [ebx+640]",
    "shufps xmm1, xmm1, 0",
    "cvttsd2si ecx, xmm0",
    "cvtsi2sd xmm0, ecx",
    "cvtpi2ps xmm0, mm0",
    "cvtsi2ss xmm0, ecx",
    "fisttp DWORD PTR [ebp-4]",
    "fld DWORD PTR [esp+732]",
    "test BYTE PTR[ebp-92], dl",
    "test dl, BYTE PTR[ebp-92]",
    "mov eax, DWORD PTR [eax+edx]",
    "mov eax, DWORD PTR [eax+edx+990141011]",
    "cmp eax, DWORD PTR [ecx+edx+4]",
    "cmp eax, DWORD PTR [ecx+4+edx]",
    "cmp eax, DWORD PTR [4+ecx+edx]",
    "movzx eax, BYTE PTR [ebp+ebx]",
    "fnstsw ax",
    "cmp ax, 17",
    "cmp dx, 0xFFFE",
    "fisub DWORD PTR [esp]",
    "fisub WORD PTR [esp]",
    "push 0",
    "push WORD PTR 0",
    "mov ax, 0",
    "movd eax, mm1",
    "movd eax, xmm1",
    "unpcklpd xmm0, xmm1",
    "unpcklps xmm0, xmm1",
    "cmpeqsd xmm1, xmm2",
    "cmpeqsd xmm3, xmm2",
    "pshufd xmm0, xmm0, 0",
    "pshufw mm0, mm0, 0",
    "pshuflw xmm0, xmm0, 0",
    "pshufhw xmm0, xmm0, 0",
    "psrldq xmm1, 4",
    "punpcklqdq xmm1, xmm2",
    "movq mm0, mm1",
    "movq xmm0, xmm1",
    "paddd xmm0, xmm1",
    "paddw xmm0, xmm1",
    "pextrw eax, xmm0, 0",
    "fld st(0)",
    "cwd",
    "cbw",
    "psrld xmm1, 1",
    "psllw xmm1, 1",
    "pause",
    # "pinsrw eax, xmm0, 0",           # BUG: not fixpoint
    "fnstcw ax", # Invalid, yet assembled to D9.F8 aka "fprem" by miasm
    "callf eax", # Invalid, yet assembled to invalid FF.D8 by miasm
    "lea ecx, [al+dl]", # Should be rejected
    "lea ecx, [dl+al]", # Should be rejected
]

@pytest.mark.parametrize("s", tests)
def test_fixpoint(s):
    # We generate the encoding of the instruction, then we decode it,
    # the we encode it again, and expect the same encoding.
    b = x86mnemo.asm(s)
    assert len(b) > 0                  # Cannot asm
    l = x86mnemo.dis(b[0])
    str_l = str(l)
    str_b = x86mnemo.asm(str_l)
    if not set(b) <= set(str_b):
        # Note: we use <= and not ==
        # because the encoding of a label==0 is not all encodings of 0
        print("Non fixpoint for asm of %r"%s)
        def show(s,b):
            print("%-40s => %s"%(s,[binascii.unhexlify(_) for _ in b]))
        show(s,b)
        show(str_l,str_b)
    assert set(b) <= set(str_b)        # Not fixpoint
